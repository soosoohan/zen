<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4YZHC1G9FN"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-4YZHC1G9FN');
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Breeze zen- solo Word Search Game | Soosooland</title>
    <!-- SEO Meta Tags -->
    <meta name="description" content="large word grid! Find clovers and daisies and words. Strategic word search puzzle game.">
    <meta name="keywords" content="word game, word search, word puzzle, vocabulary game, strategic word game, brain puzzle, word finder">
    <meta name="author" content="Soosooland">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Breeze zen- large Word Search">
    <meta property="og:description" content="Find clovers, daisies and words">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://soosooland.com/zen/zen_eng.html">
    <meta property="og:image" content="https://soosooland.com/images/worpuzz.jpeg">
    <meta property="og:site_name" content="Soosooland">
    <link rel="canonical" href="https://soosooland.com/zen/zen_eng.html">
    <link rel="alternate" hreflang="ko" href="https://soosooland.com/zen/zen_kor.html">
    <link rel="alternate" hreflang="en" href="https://soosooland.com/zen/zen_eng.html">
    <link rel="stylesheet" href="https://soosooland.com/css/protection.css">
    <script src="https://soosooland.com/js/protection.js"></script>
<style>
 * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
 }
 body {
    font-family: Arial, sans-serif;
    background: #145454;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    padding: 10px;
  }
.back-button {
    position: absolute;
    top: 20px;
    left: 20px;
    padding: 8px 10px;
    font-size: 1.5em;
    font-weight: bold;
    background-color: #CFF9FF;
    color: #0A6A79;
    border-radius: 12px;
    border: none;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 100;
}
.back-button:hover {
    background-color: #1baf8f;
    color: #fff;
}

  h1 {
    font-size: 1.8em;
    margin: 20px 0 10px;
    color: #EF0;
  }

  p {
    margin: 0 0 10px;
    font-size: 1.3em;
    color: #EF0;
    text-align: center;
    line-height: 1.4;
  }

  .game-area {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-bottom: 20px;
  }

  .game-button {
    font-size: 18px;
    background-color: #FFD6BA;
    padding: 10px 22px;
    margin: 8px;
    color: #7A2E2E;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }

  .game-button:hover {
    background-color: #FF9494;
    color: white;
    transform: scale(1.05);
  }

  /* ë°ìŠ¤í¬í†±: ê°€ë¡œ ë°°ì¹˜ */
  .container {
    display: flex;
    align-items: flex-start;
    gap: 20px;
    margin-bottom: 10px;
    width: 100%;
    max-width: 1000px;
    justify-content: center;
  }

  .cell {
    width: 100%;
    height: 100%;
    aspect-ratio: 1 / 1;
    background-color: #CFF9FF;
    color: #0A6A79;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.5em;
    font-weight: bold;
    cursor: pointer;
    user-select: none;
    border-radius: 4px;
  }

  .revealed {
  background-color: #fff;  /* ê¸°ë³¸ í°ìƒ‰ */
  font-size: 1.5em;
}

.revealed.clover {
  background-color: #c8f7c5;  /* ì—°í•œ ì´ˆë¡ */
  font-size: 1.5em;
}

.revealed.clover span {
  font-family: "Apple Color Emoji", "Segoe UI Emoji", sans-serif;
}

.revealed.daisy {
  background-color: #c8f7c5;  /* ì—°í•œ ì´ˆë¡ (í´ë¡œë²„ë‘ ê°™ê²Œ) */
  font-size: 1.5em;
}

.revealed.daisy span {
  font-family: "Apple Color Emoji", "Segoe UI Emoji", sans-serif;
}

.revealed.mistake {
  background-color: #fff
}
.revealed.special-reveal {
  background-color: #c8f7c5;  /* ì—°í•œ ì´ˆë¡ - í´ë¡œë²„/ë°ì´ì§€ì— ì˜í•´ ì—´ë¦° ì¹¸ */
}

  /* ë°ìŠ¤í¬í†± ì ìˆ˜íŒ */
  #npcScore, #userScore {
    background: #209087;
    color: #fff;
    width: 180px;
    height: 562px;
    padding: 15px;
    box-sizing: border-box;
    border-radius: 12px;
    flex-shrink: 0;
  }
  
  #npcScore h2, #userScore h2 {
    font-size: 1.2em;
    margin-top: 0;
    margin-bottom: 10px;
  }
  
  #npcScore p, #userScore p {
    font-size: 1.1em;
    margin: 5px 0;
    text-align: left;
 }

  /* ëª¨ë°”ì¼ ì ìˆ˜íŒ - ê¸°ë³¸ì ìœ¼ë¡œ ìˆ¨ê¹€ */
  .score-container {
    display: none;
  }

  .word-owned-user {
    background-color: #a0fab5 !important;
  }
  
  .word-owned-npc {
    background-color: #f7cdf7;
  }

  #currentTurn {
    font-size: 20px;
    margin: 10px;
    color: #FFE680;
    font-weight: bold;
  }

  #game {
    display: grid;
    grid-template-columns: repeat(14, 1fr);
    grid-template-rows: repeat(14, 1fr);
    grid-gap: 4px;
    padding: 10px;
    background-color: #0E756D;
    border-radius: 12px;
    width: 562px;
    height: 562px;
    box-sizing: border-box;
    flex-shrink: 0;
  }

  .hidden {
    display: none;
  }

  .btn-container {
    display: flex;
    gap: 10px;
    margin: 15px;
  }
  
  button {
    font-size: 1.1em;
    padding: 10px 20px;
    cursor: pointer;
    background-color: #CFF9FF;
    color: #0A6A79;
    border-radius: 12px;
    border: none;
  }
  
  button:hover {
    background-color: #1baf8f;
    color: #fff;
  }

  /* ëª¨ë°”ì¼ ë°˜ì‘í˜• */
  @media (max-width: 940px) {
    h1 {
      font-size: 2.5em;
      margin: 15px 0 5px;
    }
    
    p {
      font-size: 0.9em;
      margin: 0 10px 15px;
    }
    
    /* ëª¨ë°”ì¼: ì„¸ë¡œ ë°°ì¹˜ */
    .container {
      flex-direction: column;
      align-items: center;
      width: 100%;
      gap: 0;
    }
    
    #game {
      width: 95%;
      max-width: 562px;
      height: auto;
      aspect-ratio: 1 / 1;
      grid-gap: 3px;
    }

    .cell {
      font-size: 1.5em;
      font-weight: bold;
  }

    .revealed.clover,
    .revealed.daisy {
      font-size: 1.5em;
    }
    
    /* ë°ìŠ¤í¬í†± ì ìˆ˜íŒ ìˆ¨ê¹€ */
    #npcScore, #userScore {
      display: none !important;
    }
    
    /* ëª¨ë°”ì¼ ì ìˆ˜íŒ í‘œì‹œ */
    .score-container {
      display: flex !important;
      flex-direction: column;
      gap: 10px;
      width: 95%;
      max-width: 560px;
      margin-top: 15px;
    }
    
    .score-container > div {
      background-color: #0E756D;
      color: #fff;
      width: 100%;
      padding: 12px;
      box-sizing: border-box;
      border-radius: 12px;
    }
    
    .score-container h2 {
      font-size: 1em;
      margin: 0 0 8px;
    }
    
    .score-container p {
      font-size: 0.95em;
      display: inline-block;
      margin: 3px 6px;
      color: #fff;
      text-align: left;
   }
    
    .btn-container {
      margin: 15px 0;
      width: 95%;
      max-width: 480px;
      justify-content: center;
    }
    
    button {
      font-size: 1em;
      padding: 12px 25px;
      flex: 1;
      max-width: 150px;
    }
  }
</style>

</head>

<body>
<button class="back-button"  onclick="location.href='index.html'">â†</button>
<h1 id="game-title">ê²Œì„ ì œëª©</h1>
<p id="game-desc">ê²Œì„ ì„¤ëª…</p>

<div id="currentTurn"></div>

<!-- ë°ìŠ¤í¬í†±: ê²Œì„íŒ + ì–‘ìª½ ì ìˆ˜íŒ -->
<div class="container">
  <div id="npcScore">
    <h2>INFO:</h2>
    <p id="wordsDisplay">Words: 0 / 0</p>
    <p id="mistakesDisplay">Mistakes: 0 / 20</p>
    <p id="cloverCountDisplay">Clovers: 0</p>
    <p id="daisyCountDisplay">Daisies: 0</p>
  </div>
  <div id="game"></div>
  <div id="userScore">
    <h2>FOUND WORDS:</h2>
  </div>
</div>

<!-- ëª¨ë°”ì¼: ê²Œì„íŒ ì•„ë˜ ì ìˆ˜íŒ -->
<div class="score-container">
  <div id="info-mobile">
    <h2>INFO</h2>
    <p id="wordsDisplayMobile">Words: 0 / 0</p>
    <p id="mistakesDisplayMobile">Mistakes: 0 / 20</p>
    <p id="cloverCountDisplayMobile">Clovers: 0</p>
    <p id="daisyCountDisplayMobile">Daisies: 0</p>
  </div>
  <div id="found-mobile">
    <h2>FOUND WORDS</h2>
  </div>
</div>
<div class="btn-container">
  <button id="retryBtn">â†» Restart</button>
</div>

<script>
const gridSize = 14;
const totalCells = gridSize * gridSize;

let board, revealed, wordMap, foundWords, foundBy, words, usedIndexes;
let clovers = new Set(), daisies = new Set();
let resultShown = false;
let mistakes = 0;
const mistakeLimit = 20; // Breeze rule

const gameEl = document.getElementById('game');
const userScoreEl = document.getElementById('userScore');
const npcScoreEl = document.getElementById('npcScore');
const userScoreMobileEl = document.getElementById('found-mobile');
const npcScoreMobileEl = document.getElementById('info-mobile');
const retryBtn = document.getElementById('retryBtn');
const currentTurnEl = document.getElementById('currentTurn');
const wordsDisplay = document.getElementById('wordsDisplay');
const mistakesDisplay = document.getElementById('mistakesDisplay');
const cloverCountDisplay = document.getElementById('cloverCountDisplay');
const daisyCountDisplay = document.getElementById('daisyCountDisplay');
const wordsDisplayMobile = document.getElementById('wordsDisplayMobile');
const mistakesDisplayMobile = document.getElementById('mistakesDisplayMobile');
const cloverCountDisplayMobile = document.getElementById('cloverCountDisplayMobile');
const daisyCountDisplayMobile = document.getElementById('daisyCountDisplayMobile');

window.onload = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const poolFile = urlParams.get('pool');
  if (!poolFile) {
    words = ['GAME', 'ABOUT', 'ACTOR', 'PUZZLE', 'ACROSS', 'ADDRESS', 'AIRPORT', 'ANYTHING', 'BATHROOM', 'AFTERNOON', 'BEAUTIFUL' ];
    init();
    return;
  }

  fetch('wordpools/' + poolFile + '.json')
    .then(res => res.json())
    .then(data => {
      document.getElementById('game-title').textContent = data.title || 'ê²Œì„ ì œëª©';
      const rawText = data.description || 'ê²Œì„ ì„¤ëª…';
      const htmlText = rawText.replace(/\n/g, '<br>');
      document.getElementById('game-desc').innerHTML = htmlText;

      words = [];
      for (let length in data.words) {
        const count = data.wordCount[length] || 0;
        words.push(...getRandomSample(data.words[length], count));
      }
      console.log('ì´ ë‹¨ì–´ ìˆ˜:', words.length);
      console.log('ë‹¨ì–´ ëª©ë¡:', words);
      
      init();
    })
    .catch(err => {
      document.body.innerHTML = '<p>âŒ ì›Œë“œí’€ ë¡œë”© ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + err.message + '</p>';
    });
};

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function getRandomSample(arr, count) {
  if (count >= arr.length) return [...arr];
  const shuffled = [...arr];
  shuffle(shuffled);
  return shuffled.slice(0, count);
}

function init() {
  board = Array(totalCells).fill(null);
  revealed = Array(totalCells).fill(false);
  wordMap = {};
  foundWords = new Set();
  foundBy = { user: [] };
  usedIndexes = new Set();
  clovers.clear();
  daisies.clear();
  resultShown = false;
  mistakes = 0;

  createGrid();

  if (placeAllWordsWithVariety()) {
    console.log('ëª¨ë“  ë‹¨ì–´ê°€ ì„±ê³µì ìœ¼ë¡œ ë°°ì¹˜ë˜ì—ˆìŠµë‹ˆë‹¤ (3ë°©í–¥ ì‚¬ìš©)');
  } else {
    console.log('ë°©í–¥ ê²€ì¦ ì‹¤íŒ¨ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
    let placedWords = [];
    const sortedWords = [...words].sort((a, b) => b.length - a.length);
    for (let word of sortedWords) {
      let placed = false;
      for (let attempt = 0; attempt < 500; attempt++) {
        if (placeWord(word)) {
          placedWords.push(word);
          placed = true;
          break;
        }
      }
      if (!placed) console.log('ë°°ì¹˜ ì‹¤íŒ¨í•œ ë‹¨ì–´:', word);
    }
    console.log('ì‹¤ì œ ë°°ì¹˜ëœ ë‹¨ì–´ ìˆ˜:', placedWords.length);
  }

  // Breeze rules: place specials by percentage of total cells, on empty positions only
  const cloverCount = Math.floor(totalCells * 0.1); // 10%
  const daisyCount = Math.floor(totalCells * 0.1);  // 10%
  placeDaisies(daisyCount);
  placeClovers(cloverCount);
  fillEmptyCells();
  updateScore();
  updateInfoDisplay();

  checkGameEnd();
}

function createGrid() {
  gameEl.innerHTML = '';
  for (let i = 0; i < totalCells; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.onclick = () => { 
      if (!resultShown) {
        handleClick(i);
      }
    };
    gameEl.appendChild(cell);
  }
}

function canPlaceWord(word, x, y, dx, dy) {
  for (let i = 0; i < word.length; i++) {
    let nx = x + dx * i, ny = y + dy * i;
    if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) return false;
    
    let idx = ny * gridSize + nx;
    if (board[idx] && board[idx] !== word[i]) return false;
    if (usedIndexes.has(idx)) return false;
  }
  return true;
}

function placeWord(word) {
  const directions = [
    { x: 1, y: 0 },
    { x: 0, y: 1 },
    { x: 1, y: 1 },
  ];
  
  const shuffledDirections = directions.sort(() => Math.random() - 0.5);
 
  for (let dir of shuffledDirections) {
    const startY = Math.floor(Math.random() * gridSize);
    for (let i = 0; i < gridSize; i++) {
      const y = (startY + i) % gridSize;
      for (let x = 0; x < gridSize; x++) {
        if (canPlaceWord(word, x, y, dir.x, dir.y)) {
          let positions = [];
          for (let i = 0; i < word.length; i++) {
            let nx = x + dir.x * i, ny = y + dir.y * i, idx = ny * gridSize + nx;
            board[idx] = word[i];
            usedIndexes.add(idx);
            positions.push(idx);
          }
          wordMap[word] = {
            positions: positions,
            direction: [dir.x, dir.y]
          };
          return true;
        }
      }
    }
  }
  return false;
}

function checkDirectionVariety() {
  let directionCount = {
    '1,0': 0,
    '0,1': 0,
    '1,1': 0
  };
  
  for (let word in wordMap) {
    const direction = wordMap[word].direction;
    const key = direction[0] + ',' + direction[1];
    if (directionCount.hasOwnProperty(key)) {
      directionCount[key]++;
    }
  }
  
  console.log('ë°©í–¥ë³„ ì‚¬ìš© íšŸìˆ˜:', directionCount);
  return directionCount['1,0'] > 0 && directionCount['0,1'] > 0 && directionCount['1,1'] > 0;
}

function placeAllWordsWithVariety() {
  let attempts = 0;
  const maxAttempts = 10;
  
  do {
    board = Array(totalCells).fill(null);
    usedIndexes.clear();
    wordMap = {};
    
    let allPlaced = true;
    const sortedWords = [...words].sort((a, b) => b.length - a.length);
    
    for (let word of sortedWords) {
      if (!placeWord(word)) {
        allPlaced = false;
        break;
      }
    }
    
    if (allPlaced && checkDirectionVariety()) {
      console.log(`ì„±ê³µ! ${attempts + 1}ë²ˆì§¸ ì‹œë„ì—ì„œ 3ë°©í–¥ ëª¨ë‘ ì‚¬ìš©ë¨`);
      return true;
    }
    
    attempts++;
    console.log(`${attempts}ë²ˆì§¸ ì‹œë„ ì‹¤íŒ¨ - ë‹¤ì‹œ ì‹œë„`);
  } while (attempts < maxAttempts);
  
  console.log('ìµœëŒ€ ì‹œë„ íšŸìˆ˜ ì´ˆê³¼ - ê¸°ë³¸ ë°°ì¹˜ë¡œ ì§„í–‰');
  return false;
}

// ë‘ ìœ„ì¹˜ ê°„ì˜ ê±°ë¦¬ ê³„ì‚°
function getDistance(idx1, idx2) {
  const x1 = idx1 % gridSize;
  const y1 = Math.floor(idx1 / gridSize);
  const x2 = idx2 % gridSize;
  const y2 = Math.floor(idx2 / gridSize);
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

// ì£¼ì–´ì§„ ìœ„ì¹˜ê°€ ì´ë¯¸ ë°°ì¹˜ëœ íŠ¹ìˆ˜ íƒ€ì¼ë“¤ê³¼ ì¶©ë¶„íˆ ë©€ë¦¬ ë–¨ì–´ì ¸ ìˆëŠ”ì§€ í™•ì¸
function isFarEnough(index, existingSpecials, minDistance) {
  for (let specialIdx of existingSpecials) {
    if (getDistance(index, specialIdx) < minDistance) {
      return false;
    }
  }
  return true;
}

// place specials only on empty tiles (not occupied by words), with minimum distance between them
function placeClovers(count) {
  const emptyIndices = [];
  for (let i = 0; i < totalCells; i++) {
    if (!usedIndexes.has(i) && !clovers.has(i) && !daisies.has(i) && !board[i]) {
      emptyIndices.push(i);
    }
  }
  shuffle(emptyIndices);
  
  const minDistance = 2; // í´ë¡œë²„ ê°„ ìµœì†Œ ê±°ë¦¬
  const placedClovers = [];
  
  for (let idx of emptyIndices) {
    if (placedClovers.length >= count) break;
    
    // ì´ë¯¸ ë°°ì¹˜ëœ í´ë¡œë²„ë“¤, ê·¸ë¦¬ê³  ë°ì´ì§€ë“¤ê³¼ë„ ê±°ë¦¬ í™•ì¸
    const allSpecials = [...placedClovers, ...Array.from(daisies)];
    if (isFarEnough(idx, allSpecials, minDistance)) {
      clovers.add(idx);
      placedClovers.push(idx);
    }
  }
  
  console.log('ë°°ì¹˜ëœ í´ë¡œë²„ ìˆ˜:', clovers.size);
}

function placeDaisies(count) {
  const emptyIndices = [];
  for (let i = 0; i < totalCells; i++) {
    if (!usedIndexes.has(i) && !clovers.has(i) && !daisies.has(i) && !board[i]) {
      emptyIndices.push(i);
    }
  }
  shuffle(emptyIndices);
  
  const minDistance = 2; // ë°ì´ì§€ ê°„ ìµœì†Œ ê±°ë¦¬
  const placedDaisies = [];
  
  for (let idx of emptyIndices) {
    if (placedDaisies.length >= count) break;
    
    // ì´ë¯¸ ë°°ì¹˜ëœ ë°ì´ì§€ë“¤ê³¼ ê±°ë¦¬ í™•ì¸
    if (isFarEnough(idx, placedDaisies, minDistance)) {
      daisies.add(idx);
      placedDaisies.push(idx);
    }
  }
  
  console.log('ë°°ì¹˜ëœ ë°ì´ì§€ ìˆ˜:', daisies.size);
}

function fillEmptyCells() {
  // ê½ƒë°­ í…Œë§ˆ - ë¶€ë“œëŸ¬ìš´ ìƒ‰ê°ì˜ ê½ƒë“¤
  const filler =  ['ğŸŒ±','ğŸŒ¾','ğŸ','ğŸ‚','ğŸƒ','ğŸª´','ğŸª¾','ğŸŒ³','ğŸŒ²','ğŸŒ´','ğŸ„','ğŸŒµ','ğŸŒ¿'];
  shuffle(filler);
  let i = 0;
  for (let j = 0; j < totalCells; j++) {
    if (!board[j]) {
      board[j] = filler[i++ % filler.length];
    }
  }
}

function reveal(index, triggeredBySpecial = false) {
  if (revealed[index]) return;
  revealed[index] = true;
  const cell = gameEl.children[index];
  cell.classList.add('revealed');
  
  if (clovers.has(index)) {
    cell.innerHTML = '<span>ğŸ€</span>';
    cell.classList.add('clover');
    // reveal neighbors (4-direction)
    const directions = [-gridSize, gridSize, -1, 1];
    for (let d of directions) {
      const newIdx = index + d;
      if (newIdx >= 0 && newIdx < totalCells) {
        if (d === -1 || d === 1) {
          if (Math.floor(index / gridSize) === Math.floor(newIdx / gridSize)) {
            reveal(newIdx, true);
          }
        } else {
          reveal(newIdx, true);
        }
      }
    }
      } else if (daisies.has(index)) {
  const img = document.createElement('img');
  img.src = 'daisy_64x64.png';
  img.alt = 'Daisy';
  img.style.width = '24px';
  img.style.height = '24px';
  cell.appendChild(img);
    const x = index % gridSize;
    const y = Math.floor(index / gridSize);
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue;
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
          const nIdx = ny * gridSize + nx;
          if (!revealed[nIdx]) reveal(nIdx, true);
        }
      }
    }
  } else {
    cell.textContent = board[index];
    
    // ë‹¨ì–´ ê¸€ìê°€ ì•„ë‹ˆê³ , íŠ¹ìˆ˜ íƒ€ì¼ì— ì˜í•´ ì—´ë¦° ê²½ìš°ë§Œ ì´ˆë¡ìƒ‰
    const isWordLetter = usedIndexes.has(index);
    if (triggeredBySpecial && !isWordLetter) {
      cell.classList.add('special-reveal');
    }
  }
  
  // âœ¨ ì¶”ê°€: íŠ¹ìˆ˜ íƒ€ì¼ì— ì˜í•´ ì—´ë¦° ê²½ìš°, ë‹¨ì–´ ì™„ì„± ì²´í¬
  if (triggeredBySpecial && usedIndexes.has(index)) {
    checkWords();
  }
}


function updateScore() {
  const totalWords = Object.keys(wordMap).length;
  const foundHTML = `<h2>FOUND WORDS:</h2>` + foundBy.user.map(w => `<p>${w}</p>`).join("");
  userScoreEl.innerHTML = foundHTML;
  userScoreMobileEl.innerHTML = foundHTML;
}

function updateInfoDisplay() {
  const totalWords = Object.keys(wordMap).length;
  const foundCount = foundWords.size;
  
  wordsDisplay.textContent = `Words: ${foundCount} / ${totalWords}`;
  wordsDisplayMobile.textContent = `Words: ${foundCount} / ${totalWords}`;
  mistakesDisplay.textContent = `Mistakes: ${mistakes} / ${mistakeLimit}`;
  mistakesDisplayMobile.textContent = `Mistakes: ${mistakes} / ${mistakeLimit}`;
  cloverCountDisplay.textContent = `Clovers: ${clovers.size}`;
  cloverCountDisplayMobile.textContent = `Clovers: ${clovers.size}`;
  daisyCountDisplay.textContent = `Daisies: ${daisies.size}`;
  daisyCountDisplayMobile.textContent = `Daisies: ${daisies.size}`;
}

function handleClick(index) {
  if (revealed[index] || resultShown) return;

  const isWordLetter = usedIndexes.has(index);
  const isSpecial = clovers.has(index) || daisies.has(index);

  if (isWordLetter || isSpecial) {
    reveal(index);
    if (isWordLetter) checkWords();
    updateScore();
  } else {
    // ì‹¤ìˆ˜í•œ ì¹¸
    mistakes++;
    reveal(index);
    
    // ë¶„í™ìƒ‰ìœ¼ë¡œ í‘œì‹œ
    const cell = gameEl.children[index];
    cell.classList.add('mistake');  // ì´ ì¤„ ì¶”ê°€!
    
    updateInfoDisplay();
  }

  updateInfoDisplay();
  checkGameEnd();
}

function checkWords() {
  for (let word of Object.keys(wordMap)) {
    if (foundWords.has(word)) continue;
    const pos = wordMap[word].positions;
    if (pos.every(i => revealed[i])) {
      foundWords.add(word);
      foundBy.user.push(word);
      pos.forEach(i => {
        const cell = gameEl.children[i];
        cell.classList.add('word-owned-user');
      });
      updateScore();
      updateInfoDisplay(); // ë‹¨ì–´ ì°¾ì„ ë•Œë§ˆë‹¤ ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
    }
  }
}

function checkGameEnd() {
  const totalWords = Object.keys(wordMap).length;
  if ((foundWords.size >= totalWords && totalWords > 0) || mistakes >= mistakeLimit) {
    resultShown = true;
    const userWords = foundBy.user.length;
    let resultText = '';
    if (foundWords.size >= totalWords && totalWords > 0) {
      resultText = `You Win! Found ${userWords} / ${totalWords} words.`;
    } else if (mistakes >= mistakeLimit) {
      resultText = `Game Over! Found ${userWords} / ${totalWords} words.`;
    }
    currentTurnEl.textContent = resultText;
    setTimeout(() => {
      alert(resultText);
    }, 300);
  }
}
retryBtn.onclick = () => {
  location.reload();
};
</script>

</body>
</html>
